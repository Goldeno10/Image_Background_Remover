import os
import json
import uuid
import logging
from fastapi import BackgroundTasks
from .redis_client import redis_client
from .models import ProcessingRequest
from app.services.image_processor import process_image_bytes
from app.services.storage import build_filepath
from app.services.email_notifier import send_notification
from app.services.s3_uploader import upload_to_s3
from app.config import settings


logger = logging.getLogger("uvicorn.error")

def enqueue_image_processing(
    bg: BackgroundTasks,
    request: ProcessingRequest,
    file_bytes: bytes,
    filename: str,
    task_id: str, 
    base_url: str,
):
    """
    Initiates the background worker. task_id is pre-generated by the router
    to allow the frontend to begin polling immediately.
    """
    processing_id = task_id or str(uuid.uuid4())
    
    bg.add_task(
        _background_task, 
        processing_id, 
        request, 
        file_bytes, 
        filename, 
        base_url
    )
    return processing_id


def _background_task(
    processing_id: str, 
    request: ProcessingRequest, 
    file_bytes: bytes, 
    filename: str, 
    base_url: str
):
    """
    The core AI worker. Handles image processing, local/cloud storage, 
    and direct URL generation for frontend previews.
    """
    public_url = None
    
    # 1. Initialize Task State in Redis
    state = {
        "status": "processing", 
        "email": request.email,
        "model": request.model,
        "original_name": filename,
        "error": None
    }
    redis_client.setex(
        str(processing_id), 
        settings.REDIS_TTL_SECONDS, 
        json.dumps(state)
    )

    try:
        # 2. Execute AI Background Removal
        # Uses the U2-Net session manager defined in image_processor.py
        result_img = process_image_bytes(file_bytes, request.model, request.scale)

        # 3. Handle File Format Logic
        ext = request.output_format.lower().strip(".")
        filepath = build_filepath(processing_id, ext)
        save_kwargs = {}
        
        if ext in ("jpg", "jpeg"):
            # Ensure transparency is flattened to a solid color (white) for JPEGs
            if result_img.mode in ("RGBA", "LA"):
                result_img = result_img.convert("RGB")
            save_kwargs["quality"] = request.quality
            save_kwargs["optimize"] = True
        elif ext == "webp":
            save_kwargs["quality"] = request.quality
            save_kwargs["lossless"] = False if request.quality < 100 else True

        # 4. Storage and URL Generation
        if settings.ENV == "production" and settings.AWS_USE_S3:
            # --- S3 Cloud Path ---
            s3_filename = f"processed/{processing_id}.{ext}"
            try:
                public_url = upload_to_s3(result_img, s3_filename, ext, save_kwargs)
                state.update({
                    "status": "completed",
                    "file_url": public_url,
                    "storage": "s3"
                })
            except Exception as e:
                logger.error(f"S3 Upload failed for {processing_id}: {str(e)}")
                raise RuntimeError(f"S3 upload failed")
        else:
            # --- Local Storage Path ---
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            result_img.save(filepath, **save_kwargs)
            
            # MODERN UPDATE: Generate a direct static URL for the frontend preview.
            # base_url is typically 'http://localhost:8000'
            # /processed_images/ is the static mount we added to main.py
            clean_host = base_url.rstrip("/")
            public_url = f"{clean_host}/processed_images/{processing_id}.{ext}"
            
            state.update({
                "status": "completed",
                "filename": f"{processing_id}.{ext}",
                "file_url": public_url,
                "storage": "local"
            })

        # 5. Finalize Redis State
        redis_client.setex(
            str(processing_id), 
            settings.REDIS_TTL_SECONDS, 
            json.dumps(state)
        )

        # 6. Optional Email Notification
        try:
            if public_url is not None:
                email_ok = False # send_notification(request.email, public_url)
                if not email_ok:
                    logger.warning(f"Notification failed for {request.email}")
                    state["email_status"] = "failed"
                    redis_client.setex(str(processing_id), settings.REDIS_TTL_SECONDS, json.dumps(state))
        except Exception as e:
            logger.error(f"Notification service error: {str(e)}")

    except Exception as exc:
        # 7. Comprehensive Error Catching
        logger.error(f"Task {processing_id} encountered a fatal error: {str(exc)}")
        state.update({
            "status": "failed", 
            "error": "The AI model encountered an issue processing this image format."
        })
        redis_client.setex(
            str(processing_id), 
            settings.REDIS_TTL_SECONDS, 
            json.dumps(state)
        )